package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func convertUIntToNetMask(mask uint) (string, error) {
	if mask > 32 {
		return "", fmt.Errorf("Invalid netmask!")
	}

	res := make([]string, 0, 4)
	for i := 0; i < 4; i++ {
		bt := 0
		if mask >= 8 {
			bt = 255
			mask -= 8
		} else {
			bt = 256 - (1 << (8 - mask))
			mask = 0
		}
		res = append(res, fmt.Sprintf("%d", bt))
	}

	return strings.Join(res, "."), nil
}

func convert(net string) (string, error) {
	segs := strings.Split(net, "/")

	if len(segs) != 2 {
		return "", fmt.Errorf("Invalid network!")
	}

	net, maskS := segs[0], segs[1]
	mask, err := strconv.ParseUint(maskS, 10, 32)
	if err != nil {
		return "", err
	}

	maskRes, err := convertUIntToNetMask(uint(mask))
	if err != nil {
		return "", err
	}

	return net + "/" + maskRes, nil
}

func packToOCServ(l string) string {
	cl, err := convert(l)
	if err != nil {
		log.Fatalln(os.Stderr, "Convert network error: ", err)
	}
	return "no-route " + cl + "\n"
}

const (
	xmlFormatRoute = `<dict>
	<key>class</key>
	<string>Route</string>
	<key>mode</key>
	<integer>2</integer>
	<key>networkAddress</key>
	<string>%s</string>
</dict>
`

	xmlFormatComp = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>accountName</key>
	<string>%s</string>
	<key>actions</key>
	<array/>
	<key>authType</key>
	<integer>0</integer>
	<key>autoReconnect</key>
	<integer>1</integer>
	<key>children</key>
	<array/>
	<key>class</key>
	<string>AnyConnectAccount</string>
	<key>connectionCount</key>
	<integer>2</integer>
	<key>enabled</key>
	<integer>0</integer>
	<key>encryptionMode</key>
	<integer>0</integer>
	<key>expertConfig</key>
	<array/>
	<key>flushDNS</key>
	<integer>0</integer>
	<key>groupList</key>
	<array/>
	<key>hotkeyCode</key>
	<integer>-1</integer>
	<key>hotkeyModifier</key>
	<integer>0</integer>
	<key>nameServerList</key>
	<array/>
	<key>overwriteNetConf</key>
	<integer>0</integer>
	<key>prependSearchDomains</key>
	<integer>0</integer>
	<key>readonly</key>
	<integer>0</integer>
	<key>remoteHost</key>
	<string>%s</string>
	<key>resetInterfaceOnDisconnect</key>
	<integer>0</integer>
	<key>routes</key>
	<array>
		%s
	</array>
	<key>searchDomainList</key>
	<array/>
	<key>sortIndex</key>
	<integer>0</integer>
	<key>useCSD</key>
	<integer>0</integer>
	<key>useDNSForSearchDomainOnly</key>
	<integer>0</integer>
	<key>useDefaultRoute</key>
	<integer>1</integer>
	<key>useRemoteDNS</key>
	<integer>1</integer>
	<key>userName</key>
	<string>%s</string>
</dict>
</plist>`

	shellScriptFormat = `#!/bin/bash
# This shell script is generated by ProcessNets.

%s`
)

func packRouteToShiMoXml(net string) string {
	return fmt.Sprintf(xmlFormatRoute, net)
}

func packShiMoConfig(server, username string, nets []string) string {
	routes := make([]string, len(nets), len(nets))
	for i, net := range nets {
		routes[i] = packRouteToShiMoXml(net)
	}
	return fmt.Sprintf(xmlFormatComp, server, server, strings.Join(routes, "\n"), username)
}

func packToRouteCmd(route, gateway, dev string) string {
	if len(dev) == 0 {
		return fmt.Sprintf("route add -net %s gw %s", route, gateway)
	} else {
		return fmt.Sprintf("route add -net %s gw %s dev %s", route, gateway, dev)
	}
}

func packToIpCmd(route, gateway, dev string) string {
	if len(dev) == 0 {
		return fmt.Sprintf("ip route add %s via %s", route, gateway)
	} else {
		return fmt.Sprintf("ip route add %s via %s dev %s", route, gateway, dev)
	}
}

const (
	ModeShiMo   = "shimo"
	ModeRoute   = "route"
	ModeIp      = "ip"
	ModeConvert = "convert"
)

var (
	server   string
	username string
	netsfile string
	mode     string
	output   string
	gateway  string
	dev      string
)

var processNets func([]string) string

func init() {
	flag.StringVar(&server, "server", "example.server:554", "remote server addr (for shimo)")
	flag.StringVar(&username, "username", "johndoe", "username for auth (for shimo)")
	flag.StringVar(&netsfile, "netsfile", "nets.txt", "ip file to generate default routes")
	flag.StringVar(&output, "output", "", "output file (default value is initialized after mode recognization, \n\te.g. shimo: {server}.s4account, route/ip: routes.sh, convert: ip_c.txt)")
	flag.StringVar(&mode, "mode", "shimo", "generate mode (shimo/route/ip/convert)\n\t  shimo: generate config file for ShiMo(VPN Client for MacOSX)\n\t  route/ip: generate route creation script for route/ip route commands\n\t  convert: convert each 0.0.0.0/16 into 0.0.0.0/255.255.0.0")
	flag.StringVar(&gateway, "gateway", "", "default gateway (for route/ip)")
	flag.StringVar(&dev, "dev", "", "device (for route/ip)")

	flag.Parse()

	if mode == ModeRoute || mode == ModeIp {
		if len(gateway) == 0 {
			log.Fatalln("Please specify default gateway!")
		}
	} else if mode == ModeShiMo {
		if len(server) == 0 || len(username) == 0 {
			log.Fatalln("Invalid server or username")
		}
	}

	// default output
	if mode == ModeRoute || mode == ModeIp {
		if output == "" {
			output = "routes.sh"
		}
	} else if mode == ModeShiMo {
		if output == "" {
			output = fmt.Sprintf("%s.s4account", server)
		}
	} else if mode == ModeConvert {
		if output == "" {
			output = "ip_c.txt"
		}
	} else {
		log.Fatalln("Unrecognized mode: ", mode)
	}

	if mode == ModeShiMo {
		processNets = func(nets []string) string {
			return packShiMoConfig(server, username, nets)
		}
	} else if mode == ModeRoute {
		processNets = func(nets []string) string {
			cmds := make([]string, len(nets), len(nets))
			for i, net := range nets {
				cmds[i] = packToRouteCmd(net, gateway, dev)
			}
			return fmt.Sprintf(shellScriptFormat, strings.Join(cmds, "\n"))
		}
	} else if mode == ModeIp {
		processNets = func(nets []string) string {
			cmds := make([]string, len(nets), len(nets))
			for i, net := range nets {
				cmds[i] = packToIpCmd(net, gateway, dev)
			}
			return fmt.Sprintf(shellScriptFormat, strings.Join(cmds, "\n"))
		}
	} else if mode == ModeConvert {
		processNets = func(nets []string) string {
			nets_cvrt := make([]string, len(nets))
			var err error
			for i := range nets {
				nets_cvrt[i], err = convert(nets[i])
				if err != nil {
					log.Fatalln(err)
				}
			}
			return strings.Join(nets_cvrt, "\n")
		}
	}
}

func main() {
	f, err := os.Open(netsfile)
	if err != nil {
		log.Fatalf("Can not open file %s", netsfile)
	}
	defer f.Close()
	sc := bufio.NewScanner(f)

	nets := make([]string, 0, 10000)
	for sc.Scan() {
		l := sc.Text()
		nets = append(nets, l)
	}

	if err = sc.Err(); err != nil {
		log.Fatalln(os.Stderr, "Reading file error: ", err)
	}

	wf, err := os.Create(output)
	if err != nil {
		log.Fatalf("Can not open/create file %s", output)
	}
	defer wf.Close()

	wtr := bufio.NewWriter(wf)
	_, err = wtr.WriteString(processNets(nets))
	if err != nil {
		log.Fatalln(os.Stderr, "Writing file error: ", err)
	}
	wtr.Flush()
}
